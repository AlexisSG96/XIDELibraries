/**
   ${moduleNameUpperCase} Generated Driver File
 
   @Company
     Microchip Technology Inc.
 
   @File Name
     ${moduleNameLowerCase}.c
 
   @Summary
     This is the generated driver implementation file for the ${moduleNameUpperCase} driver using ${productName}
 
   @Description
     This source file provides implementations for driver APIs for ${moduleNameUpperCase}.
     Generation Information :
         Product Revision  :  ${productName} - ${productVersion}
         Device            :  ${selectedDevice}
         Driver Version    :  2.01
     The generated drivers are tested against the following:
         Compiler          :  ${compiler} or later
         MPLAB             :  ${tool}
 */ 

 ${disclaimer}
 
 /**
   Section: Included Files
 */

#include <xc.h>
#include "${moduleNameLowerCase}.h"

/**
  Section: Global Variables
*/

uint8_t static prvValue = 0;

/**
  Section: ${moduleNameUpperCase} APIs
*/

<#list initializers as initializer>
void ${moduleNameUpperCase}_Initialize(void)
{
<#if interruptEnabled>

    /* Disable ${moduleNameUpperCase} interrupt before configuring the ${moduleNameUpperCase}
       control register.Although a comparator is disabled, an interrupt can be
       generated by changing the output polarity with the CxPOL bit of the
       CMxCON0 register,or by switching the comparator on or off with the CxON
       bit of the CMxCON0 register.*/
    ${interruptEnableBitName} = 0;
</#if>

<#list initRegisters as reg>
    // ${reg.comment}                         
    ${reg.name} = ${reg.value};

</#list>
<#if interruptEnabled>
    // Clearing IF flag before enabling the interrupt
    ${interruptFlagName} = 0;

    // Enabling ${moduleNameUpperCase} interrupt
    ${interruptEnableBitName} = 1;
 </#if>   

   // Read CMCON register 
   prvValue = ${cmconRegName};
}

</#list>
uint8_t CMP_OutputStateChangeGet(void)
{
    uint8_t stateChange = 0;
    uint8_t curValue = 0;
	
	// Read CMCON register
    curValue = ${cmconRegName};
	
	if((prvValue & 0x80) != (curValue & 0x80))
    {
        stateChange =  0x80;
    }
	if((prvValue & 0x40) != (curValue & 0x40))
    {
        stateChange |=  0x40;
    }
	
	// Load CMCON current value to prvValue
    prvValue = curValue;
    
    // Return the change in CMP output state
    return stateChange;

}

bool ${moduleNameUpperCase}_OutputStatusGet(void)
{
   
    return (unsigned char)(${cmconRegName} & 0xC0);
}

<#if interruptEnabled>
void ${isrName}(void)
{
    uint8_t read = 0;

    //Reading ${cmconRegName} will end the mismatch condition
    read = ${cmconRegName};

    // clear the CMP interrupt flag
    ${interruptFlagName} = 0;
   
}
</#if>

/**
 End of File
*/
